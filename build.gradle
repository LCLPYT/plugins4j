import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.util.stream.Collectors

plugins {
    id 'java'
    id 'com.github.johnrengelman.shadow' version '7.1.2'
    id 'maven-publish'
    id 'gradle-build-utils'
}

Properties props = loadProperties.call('publish.properties')

group project.maven_group
version gitVersion.call()

repositories {
    mavenCentral()
}

configurations {
    exampleImplementation.extendsFrom(implementation)
    exampleRuntimeOnly.extendsFrom(runtimeOnly)

    testPluginImplementation.extendsFrom(implementation)
    testPluginRuntimeOnly.extendsFrom(runtimeOnly)

    providerPluginImplementation.extendsFrom(implementation)
    providerPluginRuntimeOnly.extendsFrom(runtimeOnly)
}

dependencies {
    implementation 'org.slf4j:slf4j-api:2.0.6'
    implementation 'org.json:json:20220924'

    implementation 'com.google.code.findbugs:jsr305:3.0.2'

    exampleImplementation 'org.apache.logging.log4j:log4j-api:2.19.0'
    exampleImplementation 'org.apache.logging.log4j:log4j-core:2.19.0'
    exampleImplementation 'org.apache.logging.log4j:log4j-slf4j2-impl:2.19.0'

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.1'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.1'
    testImplementation 'org.apache.logging.log4j:log4j-api:2.19.0'
    testImplementation 'org.apache.logging.log4j:log4j-core:2.19.0'
    testImplementation 'org.apache.logging.log4j:log4j-slf4j2-impl:2.19.0'
}

sourceSets {
    example {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
    providerPlugin {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
    testPlugin {
        java {
            compileClasspath += main.output + providerPlugin.output
            runtimeClasspath += main.output + providerPlugin.output
        }
    }
}

test {
    useJUnitPlatform()
}

processTestPluginResources {
    inputs.property "version", project.version

    filesMatching("plugin.json") {
        expand "version": project.version
    }
}

processProviderPluginResources {
    inputs.property "version", project.version

    filesMatching("plugin.json") {
        expand "version": project.version
    }
}

java {
    withSourcesJar()
}

task exampleJar(type: ShadowJar) {
    from sourceSets.example.output, sourceSets.main.output
    archiveBaseName.set('example')
    archiveFileName.set("example.jar")

    manifest {
        attributes('Main-Class': 'work.lclpnet.example.Main')
    }

    configurations = [project.configurations.exampleCompileClasspath]
    dependencies {
        include(dependency('org.slf4j:slf4j-api:.*'))
        include(dependency('org.apache.logging.log4j:log4j-core:.*'))
        include(dependency('org.apache.logging.log4j:log4j-api:.*'))
        include(dependency('org.apache.logging.log4j:log4j-slf4j2-impl:.*'))
        include(dependency('org.apache.commons:commons-collections4:.*'))
        include(dependency('org.json:json:.*'))
    }
}

task testPluginJar(type: Jar) {
    from sourceSets.testPlugin.output
    archiveVersion.set(project.version.toString())
    archiveBaseName.set('testPlugin')
}

task providerPluginJar(type: Jar) {
    from sourceSets.providerPlugin.output
    archiveVersion.set(project.version.toString())
    archiveBaseName.set('providerPlugin')
}

shadowJar.enabled = false  // default shadowJar task should be disabled

artifacts {
    archives testPluginJar, exampleJar, providerPluginJar
}

abstract class DeployTask extends DefaultTask {
    @TaskAction
    def deploy() {
        final def proj = this.getProject()
        final def libsDir = proj.getBuildDir().toPath().resolve('libs')

        def provider = 'example.jar';

        final def runDir = proj.getProjectDir().toPath().resolve('run')
        if (!Files.exists(runDir)) Files.createDirectories(runDir)

        Files.copy(libsDir.resolve(provider), runDir.resolve(provider), StandardCopyOption.REPLACE_EXISTING)

        println('Files have been deployed to %s'.formatted(runDir))
    }
}

tasks.register("deploy", DeployTask)

abstract class DeployPluginsTask extends DefaultTask {
    @TaskAction
    def execute() {
        final def proj = this.getProject()
        final def libsDir = proj.getBuildDir().toPath().resolve('libs')
        final def version = proj.getVersion()

        final def pluginsDir = proj.getProjectDir().toPath().resolve('run/plugins')
        copyPlugins(libsDir, pluginsDir, version)

        println('Plugins have been deployed to %s'.formatted(pluginsDir))
    }

    static def copyPlugins(java.nio.file.Path libsDir, java.nio.file.Path pluginsDir, version) {
        if (!Files.exists(pluginsDir)) Files.createDirectories(pluginsDir)

        def plugins = ['testPlugin', 'providerPlugin']

        plugins.forEach(plugin -> {
            def testPlugin = '%s-%s.jar'.formatted(plugin, version)
            copy(libsDir.resolve(testPlugin), pluginsDir.resolve(testPlugin))
        })
    }

    static def copy(java.nio.file.Path a, java.nio.file.Path b) {
        // transfer file contents to enable plugin hot-swapping using reloading
        try (def input = new FileInputStream(a.toFile()); def output = new FileOutputStream(b.toFile())) {
            input.transferTo output
        }
    }
}

tasks.register('deployPlugins', DeployPluginsTask)

deploy.configure {
    dependsOn build
    dependsOn deployPlugins
}

deployPlugins.configure {
    dependsOn build
}

tasks.test.configure {
    dependsOn(tasks.providerPluginClasses)

    systemProperty("test.providerPluginClasspath", sourceSets.providerPlugin.getOutput().files.stream()
            .map(file -> file.getAbsolutePath()).collect(Collectors.joining(File.pathSeparator)))
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifactId = project.archives_base_name

            from components.java

            pom {
                name = 'plugins4j'
                description = 'Lightweight plugin loading and unloading at runtime.'
            }
        }
    }

    repositories {
        maven {
            def env = System.getenv()
            if (Arrays.stream("DEPLOY_URL", "DEPLOY_USER", "DEPLOY_PASSWORD").allMatch(env.&containsKey)) {
                credentials {
                    username env.get("DEPLOY_USER")
                    password env.get("DEPLOY_PASSWORD")
                }
                url env.get("DEPLOY_URL")
            } else if (Arrays.stream("mavenHost", "mavenUser", "mavenPassword").allMatch(props.&containsKey)) {
                credentials {
                    username props.getProperty('mavenUser')
                    password props.getProperty('mavenPassword')
                }
                url props.getProperty('mavenHost')
            } else {
                url "file:///${project.projectDir}/repo"
            }
        }
    }
}
